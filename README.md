# Docker Compose NGINX with self-renewing Let's Encrypt HTTPS Easy
Docker is supposed to make server deployment easy, but without the right recipe, some things may become much harder. Running an NGINX server with HTTPS via Let's Encrypt, along with auto-renewal, was one such SNAFU. Having found existing recipes on the internet for this unnecessarily complex or unreliable, the solution given here is designed to have you up and running fast.

## Enough talk. Let's go!
Create a docker node with a hosting provider:

### Digital Ocean
Install the following 1-Clicker with your digitalocean account:
https://marketplace.digitalocean.com/apps/docker

SSH into your server with the generated IP address
ssh root@<my.new.ip.address>

#### Configure a (non-root) deploy user (optional but highly recommended)
```
adduser -m deploy sudo
passwd deploy
mkdir /home/deploy/.ssh
chmod 700 /home/deploy/.ssh
cp /root/.ssh/authorized_keys /home/deploy/.ssh/authorized_keys
chown -R deploy:deploy /home/deploy/.ssh
chmod 600 /home/deploy/.ssh/authorized_keys
usermod -aG docker deploy
newgrp docker
```

#### Configure the firewall of your new server to accept web requests
```
sudo ufw allow 22/tcp
sudo ufw allow http
sudo ufw allow https
sudo ufw reload
```

### Get and configure this Docker Compose recipe
```
git clone https://github.com/colinbrogan/nginx_https_easy_docker
```
Change DOMAIN in the .env file to your domain. 

If you haven't already pointed the domains' nameservers to your new server, do so now.

#### Connect to your docker server
If you want to control the remote server from your local environment (recommended), setup the docker context:
```
docker context create \
    --docker host=ssh://deploy@<my.new.ip.address> \
    my_context
docker use my_context
```

#### Deploy!
```
docker compose up --build -d
```


## Why?
Getting docker to create a Let's encrypt certificate and configure NGINX with it is one thing. To then have it autorenew (so your clients' website doesn't go down in 3 months) is quite another accomplishment. Docker is designed for each service to run a single command, so we have to come up with entrypoints to coordinate the two services (nginx and certbot).

## How?
We have two seperate configurations files for NGINX `nginx/precert.conf`, and `nginx/cert.conf`. precert.conf is designed to run NGINX only on port 80 (http), so that cerbot can perform it's acme challenge. We do this because NGINX would exit with an error if we configured it for HTTPS before getting the certificate generated by acme challenge. We have to switch to the full configuration of NGINX (cert.conf) later. cert.conf is also where you would add any custom nginx configuration for your particular project.

Observe the nginx services' entrypoint `nginx/cert-entrypoint.sh`. We first overwrite all nginx configuration files with the domain defined in .env. We then run an infinite while loop in the background which checks if the cert files exist every 10 seconds, before moving to the primary process of running nginx (which at this point will be running cert.conf configuration). This gets us up on port 80, waiting for the certbot service to do it's acme test. As soon as the file check observes the certificate exists (certbot completed the acme test), we then switch the nginx configuration file to cert.conf, which is the full configuration for your site employeing the https certificates, and reload nginx. We now switch the while loop wait time of every 10 seconds to evert 6 hours, since we now only need to reload nginx when certbot renews the certificate.

Moving to certbot's entrypoint `certbot/certbot-entrypoint.sh`, we see another file looking for the existence of the certificate. If it's not there, we generate them into the volume which is shared between nginx and certbot. We then enter an infinite loop to renew the certificate (whether pre-existing or newly generated) every 12 hours.


## Conclusion
I have yet to see a solution for NGINX and let's encrypt which manages both initial certificate generation and auto-renewal without performing atleast some of the steps manually. By creating a compose file which automatically generates and/or renews at docker's build / runtime, you can focus your efforts on your app without annoying server setup / maintenance, which is what docker was designed to do in the first place!